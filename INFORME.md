# Informe del 1er proyecto de programaci√≥n (Moogle) 
## Introducci√≥n
Con este informe escrito se pretende plantear las cuestiones m√°s relevantes de la implementaci√≥n de este Primer Proyecto de Programaci√≥n. Moogle, as√≠ denominado, es un buscador, que tiene como objetivo explorar dentro de un conjunto de documentos, y as√≠ poder ofrecerle al usuario la palabra o documento que est√° buscando... si se encuentra. A continuaci√≥n se explicar√° la arquitectura del proyecto, as√≠ como sus m√©todos m√°s interesantes.

## Clases
Este proyecto consta de varias clases como: LeerDocumentos, TFIDF, SimilitudCoseno, Snippet, Levenshtein, Operadores y Moogle.
### Normalizaci√≥n de documentos
LeerDocumentos es la clase encargada de leer los documentos que se encuentran en la carpeta content. Esta clase posee dos m√©todos: LeerDocs y LeerPalabras. LeerDocs es el m√©todo encargado de guardar en un array la direcci√≥n donde se encuentras los archivos as√≠ como almacenar en otro array los nombres de los documentos como tal (sin la direcci√≥n delante). Con el m√©todo LeerPalabras, utilizando el array que contiene los documentos y el m√©todo StreamReader, podemos guardar en una lista todas las palabras que contiene cada documento, para poder posteriormente trabajar con ella. Para este m√©todo se investig√≥ como normalizar las palabras (convertirlas a m√≠nusculas, quitar las comas, puntos, espacios, etc), y se utilizar√≥n varios m√©todos valios√≠simos como Char.IsLetterOrDigit y .ToLower. Finalmente se alamacen√≥ todas las palabras en una lista. Tambi√©n se trabaj√≥ con diccionarios, en este caso para guardar todas las palabras por documentos, y que tuvieran de Value la cantidad de repeticiones por cada documentos.

### TF-IDF
Una de las clases m√°s importantes e interesantes, es la clase llamada TFIDF (Frecuencia de t√©rmino - Frecuencia inversa de documento). Con el TFIDF podemos saber cuan relevante es una palabra en un conjunto de documentos, y se utiliza mucho en sistemas de recuperaci√≥n de informaci√≥n, entre ellos los propios motores de b√∫squeda de internet. Por una parte est√° el TF (a mayor frecuencia de un t√©rmino en un documento, mayor importancia tendr√°), por otra parte el IDF (a mayor frecuencia en los documentos, menor importancia del t√©rmino). Por ejemplo el IDF no tiene en cuenta palabras muy usadas en muchos documentos como los art√≠culos, conjunciones, preposiciones, por lo tanto su tfidf es muy peque√±o, sin embargo el tfidf de las palabras m√°s raras es muy alto. 
La clase TFIDF posee varios m√©todos, entre ellos se encuentran: tfidf, Query y TFIDF_Query. El primero se encarga de calcular el TFIDF de todas las palabras de los documentos, y los guarda en un diccionario donde el Key es la palabra por documento y el Value es su valor de TFIDF. Para calcular este valor utilic√© una f√≥rmula:
TF = n√∫mero de veces que aparece un t√©rmino en un documento/n√∫mero total de palabras
IDF = log10 (n√∫mero total de documentos/cantidad de documentos que contienen a esa palabra)
TFIDF = TF * IDF
El m√©todo Query lo que hace es normalizar el query, como mismo se hizo con las palabras de los documentos, y una vez que est√©n normalizados, los guardamos en una lista. El m√©todo TFIDF_Query hace el mismo proceso del m√©todo tfidf, pero con la query, pero en este caso nos devuelve un array de doubles con los TFIDF de cada palabra de la query por documento.

### Similitud del Coseno (Score)
Otra clase bastante interesante es la llamada SimilitudCoseno, que consta de dos m√©todos: Matriz y SimCos. Con la implementaci√≥n de esta clase ya el proyecto busca, quiz√° no de manera muy eficiente pero llegado a este punto ya puede buscar t√©rminos. Primeramente se encuentra el m√©todo Matriz (que ayuda a calcular el score o similitud del coseno). Este m√©todo coloca en una matriz de n * m, n (cant documentos), m (cant palabras de la query), el TFIDF de cada palabra de la query que se encuentra en el documento, si la palabra de la query no aparece en el documento, entonces esa posici√≥n en la matriz es igual a 0. El segundo m√©todo utiliza lo que se conoce como Similitud del Coseno. Este es un m√©todo para saber cu√°n similares son dos textos entre s√≠. Este m√©todo devuelve un array de doubles, de longitud igual a la cantidad de documentos. La similitud del coseno consiste en comparar vectores, y si son similares devolver√° un valor muy cercano a 1 (o 1), pues quiere decir que sus vectores se superponen, y por lo tanto el √°ngulo donde el coseno es 1, es 0 grados. Todo lo contrario pasa cuando los vectores no se asemejan en nada, sus vectores ser√°n ortogonales entre s√≠ y devolver√° un valor muy cerca a 0 (o 0). Ya yendo a el algor√≠tmo en s√≠, y luego de haber indagado bastante sobre este tema, para calcular la similitud del coseno entre el TFIDF de la query y la matriz anteriormente hallada, debemos aplicar el producto matricial entre las mismas. Para esto utilic√© la f√≥rmula:
### simCos = v1 * v2 / |v1|* |v2|
v1 es el valor del TFIDF de una palabra de la query y v2 el valor del TFIDF de la palabra de la query en el documento (valor de esa posici√≥n en la matriz).

### Snippet
Esta clase tiene dos m√©todos: BuscarSnippet y Snippet. La clase tiene como objetivo devolver un pedazo de texto, a partir de las diferentes palabras introducidas en el query. Para esto deber√° recorrer todos los documentos y cuando se encuentre la palabra que tenga mayor relevancia del documento, entonces devolver√° un pedazo de texto de cantidad m√°xima igual a 31 aproximadamente, que contenga a esa palabra.

### Operadores
Los operadores se crearon para hacer la b√∫squeda mucho m√°s f√°cil, por ejemplo, cuando el usuario quiere un t√©rmino en espec√≠fico, cuando no quiere que aparezca ese t√©rmino, entre otras muchas funcionalidades. Implement√© diferentes operadores como: 

El operador de Anulaci√≥n (!) que hace que no aparezca el documento que contiene la palabra con el operador ! delante. Este m√©todo recorre todos los documentos y si se encuentra la palabra introducida en la query convierte el score del documento en 0.

El operador de Relevancia (*) que hace que se priorice el documento, y mientras m√°s asteriscos tenga la palabra delante, m√°s importancia va a tener. Este m√©todo recorre todos los documentos y si se encuentra la palabra introducida en la query multiplica el score del documento varias veces y le suma 1.

Tambi√©n est√° el operador (^), que significa que esa palabra (documento en donde se encuentre) se tiene que devolver siempre. Este m√©todo recorre todos los documentos y si no se encuentra la palabra en el documento analizado entonces convierte el score en 0.

Por √∫ltimo se encuentra el operador de cercan√≠a (~), operador que se tiene que encontrar entre dos palabras, para de esta forma, que devuelva el documento donde est√°s dos palabras est√©n m√°s cerca. Dicho operador se implement√≥ de la siguiente manera:
- Primero se almacen√≥ en una lista todas las palabras de la query, incluyendo operadores.
- Luego se indentifica la posici√≥n (posiciones) de la lista donde se encuentra el operador (operadores)de cercan√≠a (si se encuentra) y las dos palabras a analizar su distancia.
- Se almacena en un array todas las palabras que contengan al operador, para luego recorrer posici√≥n por posici√≥n del array, y alamcenar en dos variables la primera y la segunda palabra a comparar. Se analiza a su vez si ellas estan en los documentos. Si est√°n ambas en un documento, entonces se halla la distancia entre los indices donde se encuentran dichas palabras. Asimismo, se compara esta distancia con otras que puedan existir en otros txt, para quedarnos con la m√°s peque√±a, y con el indice del documento al que le pertenece dicha distancia.
- Por √∫ltimo, al tener la posici√≥n del documento que contiene la menor distancia entre esas palabras, solamente se aumenta el score de ese txt, en este caso se le sum√≥ 2.

### Distancia de Levenshtein
Es un algor√≠tmo que calcula la distancia entre las palabras, para ver que nivel de semejanza tiene una con respecto a otra. Su nombre es en honor a Vladimir Levenshtein, cient√≠fico ruso, qui√©n se encarg√≥ de descubrir el √∫til funcionamiento de este m√©todo de sugerencia. En este proyecto este algor√≠tmo tiene mucha utilidad, pues es empleado con el objetivo de que si el usuario introduce una palabra parecida a una que se encuentra en los textos, Moogle sea capaz de sugerirle el texto que mayor semejanza tenga. La distancia de Levenshtein lo que hace es devolver un n√∫mero, que mientras menor sea, significa que menor cantidad de cambios (eliminaci√≥n, inserci√≥n, sustituci√≥n) hay entre una palabra y otra, por lo tanto esa palabra que menor cantidad de cambios posea, es la palabra sugerida. La clase Levenshtein consta de tres m√©todos: SimilitudPalabras, MenorDist, Calculo. El m√©todo Calculo, es el que devuelve un n√∫mero (distancia). El m√©todo SimilitudPalabras es el m√©todo que trabaja con la sugerencia y con los operadores tambi√©n, en el caso de los operadores lo que hace el m√©todo es hallar la sugerencia de la palabra, pero si tiene operadores, guardar las sugerencias con sus respectivos operadores. 

Este algor√≠tmo consiste en una matriz de largo igual a la cantidad de letras que tiene la primera palabra (palabra introducida en la query), y ancho (palabra a comparar, palabra del documento). En cada posici√≥n de la matriz va un numero que var√≠a en dependencia de que letras (valores) est√°n en ese i, y en ese j. Por ejemplo si hasta ese momento, todas las letras coinciden, entonces el valor que le corresponde a cada casilla de la matriz es 0, pues no hay diferencia entre una cadena y otra. Sin embargo si en un determinado momento hay dos letras que no coinciden, el valor ser√≠a distinto de 0, pues ya existir√≠a una diferencia entre una cadena y otra. Mientras m√°s diferentes sean las cadenas entre si, esos n√∫meros tienden a crecer. Para terminar, la distancia de Levenshtein ser√≠a el valor que se ubica en la √∫ltima posici√≥n de la matriz, que no es m√°s que la diferencia que hay entre una palabra y la otra. Si ese valor es 0 significa que las palabras son iguales, si es un n√∫mero cercano a 0, signfica que se parecen teniendo alguna que otra variaci√≥n, pero si el n√∫mero est√° distanciado del 0, podr√≠a significar una diferencia importante entre las cadenas.

### Llamada a las clases
Para finalizar se encuentra la clase Moogle, donde llamo a todas las dem√°s clases y m√©todos, para poder utilizarlos en la ejecuci√≥n del programa. En esta clase se encuentra el algor√≠tmo que ordena los documentos, desde el m√°s relevante hasta el menos relevante, tambi√©n trabaja con la similitud del coseno, y aquellos documentos en los que sea un valor igual a 0, los ignora.

### Indicaciones
En la carpeta content se encuentra un peque√±o conjunto de documentos en formato txt. Para probar el funcionamiento del proyecto, se utiliza la interfaz Moogle Server. Como sugerencia, se pueden hacer algunas b√∫squedas relacionadas con estos txt, y de esta manera comprobar que funciona correctamente la l√≥gica del programa. Por ejemplo, algunas b√∫squedas ser√≠an: Leandro, Historia, Gato, Hola, Casi, Alaska (probar tambi√©n escribir estas palabras incorrectamente, y as√≠ verificar el funcionamiento de la Distancia de Leveshtein, y probar el uso de operadores tambi√©n). 
Posdata: Prob√© el funcionamiento del programa con un conjunto m√°s amplio de documentos (297 txt) y funciona pero con lentitud (alrededor de 10 o 15 minutos), por ello en el caso de agregar otros txt, sugiero que sean documentos que pesen poco, o de lo contrario... tener mucha paciencia üòÖüò•üññüèª.
